"""Package generation for multi-file output.

This module generates complete Python packages from CloudFormation templates,
organizing code into multiple files:

- __init__.py: Centralized imports and setup_resources()
- __main__.py: Entry point for python -m package_name
- params.py: Parameters, Mappings, and Conditions
- outputs.py: Output definitions
- main.py: Resources (or categorized files for large templates)

Key functions:
- generate_code(): Single-file output for simple templates
- generate_package(): Multi-file package output
"""

from __future__ import annotations

from wetwire_aws.importer.ir import IRTemplate

from .classes import (
    generate_condition_class,
    generate_mapping_class,
    generate_output_class,
    generate_parameter_class,
    generate_resource_class,
)
from .context import (
    CodegenContext,
    PackageContext,
    build_arn_pattern_map,
    build_name_pattern_map,
)
from .helpers import get_resource_category, sanitize_class_name
from .imports import generate_imports
from .topology import (
    find_strongly_connected_components,
    order_scc_resources,
    topological_sort,
)
from .values import escape_string

# =============================================================================
# Single File Generation
# =============================================================================


def generate_code(
    template: IRTemplate,
    include_main: bool = True,
) -> str:
    """
    Generate Python code from analyzed IR.

    Args:
        template: Parsed IRTemplate
        include_main: Include if __name__ == "__main__" block

    Returns:
        Complete Python module source code
    """
    ctx = CodegenContext(
        template=template,
        include_main_block=include_main,
    )

    ctx.name_pattern_map = build_name_pattern_map(template)
    ctx.arn_pattern_map = build_arn_pattern_map(template)

    # Add common imports
    ctx.add_import("wetwire_aws", "ref")
    ctx.add_import("wetwire_aws", "get_att")

    sections: list[str] = []

    # Module docstring
    if template.description:
        sections.append(
            f'"""\n{template.description}\n\nGenerated by wetwire-aws import.\n"""'
        )
    else:
        sections.append('"""Generated by wetwire-aws import."""')

    class_sections: list[str] = []

    # Parameters
    for param in template.parameters.values():
        class_sections.append(generate_parameter_class(param, ctx))

    # Mappings
    for mapping in template.mappings.values():
        class_sections.append(generate_mapping_class(mapping, ctx))

    # Conditions
    for condition in template.conditions.values():
        class_sections.append(generate_condition_class(condition, ctx))

    # Resources (in dependency order)
    sorted_resources = topological_sort(template)
    for resource_id in sorted_resources:
        resource = template.resources[resource_id]
        resource_class = generate_resource_class(resource, ctx)
        class_sections.append(resource_class)

    # Outputs
    for output in template.outputs.values():
        class_sections.append(generate_output_class(output, ctx))

    # Now generate imports
    ctx.add_import("wetwire_aws", "CloudFormationTemplate")
    sections.append(generate_imports(ctx))

    # Add class sections
    sections.extend(s for s in class_sections if s)

    # Build template function
    param_list = ""
    if template.parameters:
        param_names = ", ".join(template.parameters.keys())
        param_list = f"parameters=[{param_names}]"

    output_list = ""
    if template.outputs:
        output_names = ", ".join(f"{lid}Output" for lid in template.outputs.keys())
        output_list = f"outputs=[{output_names}]"

    args = []
    if template.description:
        args.append(f"description={escape_string(template.description)}")
    if param_list:
        args.append(param_list)
    if output_list:
        args.append(output_list)

    if args:
        args_str = ",\n        ".join(args)
        from_registry_call = (
            f"CloudFormationTemplate.from_registry(\n        {args_str},\n    )"
        )
    else:
        from_registry_call = "CloudFormationTemplate.from_registry()"

    sections.append(
        f"""
def build_template() -> CloudFormationTemplate:
    \"\"\"Build the CloudFormation template.\"\"\"
    return {from_registry_call}"""
    )

    # Main block
    if include_main:
        sections.append(
            """
if __name__ == "__main__":
    import json
    template = build_template()
    print(json.dumps(template.to_dict(), indent=2))"""
        )

    return "\n\n\n".join(sections) + "\n"


# =============================================================================
# Package Generation
# =============================================================================


def generate_package(
    template: IRTemplate,
    package_name: str,
) -> dict[str, str]:
    """
    Generate a Python package from template (multi-file output).

    Args:
        template: Parsed IRTemplate
        package_name: Name of the Python package

    Returns:
        Dict mapping filename to content, prefixed by package_name/
    """
    pkg_ctx = PackageContext(template=template)
    ctx = pkg_ctx.codegen_ctx

    ctx.add_import("wetwire_aws", "ref")
    ctx.add_import("wetwire_aws", "get_att")
    ctx.add_import("wetwire_aws", "CloudFormationTemplate")

    # Generate params.py
    params_content = _generate_params_py(pkg_ctx, template)

    # Generate outputs.py
    outputs_content = _generate_outputs_py(pkg_ctx, template)

    # Generate resource files
    resource_files = _generate_resource_files(pkg_ctx, template)

    # Generate __init__.py last
    init_content = _generate_init_py(pkg_ctx, template)

    # Generate __main__.py
    dunder_main_content = f'''"""Allow running as: python -m {package_name}."""
from wetwire_aws.cli import main

if __name__ == "__main__":
    main()
'''

    files = {
        f"{package_name}/__init__.py": init_content,
        f"{package_name}/__main__.py": dunder_main_content,
        f"{package_name}/params.py": params_content,
    }

    if outputs_content:
        files[f"{package_name}/outputs.py"] = outputs_content

    for filename, content in resource_files.items():
        files[f"{package_name}/{filename}"] = content

    return files


# =============================================================================
# Init File Generation
# =============================================================================


def _generate_init_py(pkg_ctx: PackageContext, template: IRTemplate) -> str:
    """Generate __init__.py with centralized imports and setup_resources."""
    lines = []

    # Docstring
    if template.description:
        desc = template.description.strip()
        if len(desc) > 200:
            desc = desc[:197] + "..."
        lines.append(f'"""{desc}\n\nGenerated by wetwire-aws import."""')
    else:
        lines.append('"""Generated by wetwire-aws import."""')

    lines.append("")

    ctx = pkg_ctx.codegen_ctx

    # Core imports (always needed for params.py, resources, etc.)
    # Note: Condition is imported as TemplateCondition to avoid conflict with intrinsic
    core_imports = [
        # Template building
        "CloudFormationTemplate",
        "Condition as TemplateCondition",  # For params.py conditions
        "Mapping",  # For params.py mappings
        "Output",  # For outputs.py
        "Parameter",  # For params.py parameters
        "get_att",
        "ref",
        "wetwire_aws",
        # Parameter type constants
        "AMI_ID",
        "AVAILABILITY_ZONE",
        "COMMA_DELIMITED_LIST",
        "HOSTED_ZONE_ID",
        "INSTANCE_ID",
        "KEY_PAIR",
        "LIST_AVAILABILITY_ZONE",
        "LIST_NUMBER",
        "LIST_SECURITY_GROUP_ID",
        "LIST_SUBNET_ID",
        "NUMBER",
        "SECURITY_GROUP_ID",
        "SSM_PARAMETER_STRING",
        "SSM_PARAMETER_STRING_LIST",
        "STRING",
        "SUBNET_ID",
        "VOLUME_ID",
        "VPC_ID",
    ]
    lines.append("from wetwire_aws import (")
    for name in core_imports:
        lines.append(f"    {name},")

    # Add intrinsic functions used by the template
    if ctx.intrinsic_imports:
        for name in sorted(ctx.intrinsic_imports):
            lines.append(f"    {name},")

    # Also add pseudo-parameters that may be used
    pseudo_params = {
        "AWS_ACCOUNT_ID",
        "AWS_REGION",
        "AWS_STACK_NAME",
        "AWS_STACK_ID",
        "AWS_PARTITION",
        "AWS_URL_SUFFIX",
        "AWS_NO_VALUE",
        "AWS_NOTIFICATION_ARNS",
    }
    for name in sorted(pseudo_params):
        lines.append(f"    {name},")

    lines.append(")")

    # setup_resources import
    lines.append("from wetwire_aws.loader import setup_resources")
    lines.append("")

    # Resource module imports
    resource_modules = set()
    for mod, names in ctx.imports.items():
        if mod == "wetwire_aws.resources":
            # Direct module import: ec2, s3, etc.
            resource_modules.update(names)
        elif mod.startswith("wetwire_aws.resources."):
            # Class import from module - extract module name
            resource_modules.add(mod.split(".")[-1])

    if resource_modules:
        sorted_modules = sorted(resource_modules)
        lines.append(f"from wetwire_aws.resources import {', '.join(sorted_modules)}")
        lines.append("")

    # Import params
    lines.append("from .params import *  # noqa: F403, F401")
    lines.append("")

    # Setup resources
    lines.append("# Auto-discover and import resource files in topological order")
    lines.append("setup_resources(__file__, __name__, globals())")
    lines.append("")

    # Import outputs
    if template.outputs:
        lines.append("# Import outputs after resources")
        lines.append("from .outputs import *  # noqa: F403, F401")
        lines.append("")

    # Collect names for __all__
    all_names: list[str] = ["wetwire_aws", "ref", "get_att", "CloudFormationTemplate"]
    all_names.extend(sorted(resource_modules))

    # Add config names
    for param in template.parameters.values():
        all_names.append(sanitize_class_name(param.logical_id))
    for mapping in template.mappings.values():
        all_names.append(f"{sanitize_class_name(mapping.logical_id)}Mapping")
    for condition in template.conditions.values():
        all_names.append(f"{sanitize_class_name(condition.logical_id)}Condition")

    # Add resource names
    for resource in template.resources.values():
        all_names.append(sanitize_class_name(resource.logical_id))

    # Add output names
    for output in template.outputs.values():
        all_names.append(f"{sanitize_class_name(output.logical_id)}Output")

    all_names = sorted(set(all_names))

    lines.append("__all__ = [")
    for name in all_names:
        lines.append(f'    "{name}",')
    lines.append("]")

    return "\n".join(lines) + "\n"


# =============================================================================
# Params File Generation
# =============================================================================


def _generate_params_py(pkg_ctx: PackageContext, template: IRTemplate) -> str:
    """Generate params.py with Parameters, Mappings, Conditions."""
    lines = []
    lines.append('"""Parameters, Mappings, and Conditions."""')
    lines.append("")
    lines.append("from . import *  # noqa: F403")
    lines.append("")
    lines.append("")

    ctx = pkg_ctx.codegen_ctx

    # Parameters
    for param in template.parameters.values():
        class_def = generate_parameter_class(param, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(sanitize_class_name(param.logical_id))

    # Mappings
    for mapping in template.mappings.values():
        class_def = generate_mapping_class(mapping, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(f"{sanitize_class_name(mapping.logical_id)}Mapping")

    # Conditions
    for condition in template.conditions.values():
        class_def = generate_condition_class(condition, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(
            f"{sanitize_class_name(condition.logical_id)}Condition"
        )

    while lines and lines[-1] == "":
        lines.pop()

    return "\n".join(lines) + "\n"


# =============================================================================
# Outputs File Generation
# =============================================================================


def _generate_outputs_py(pkg_ctx: PackageContext, template: IRTemplate) -> str | None:
    """Generate outputs.py with Output definitions."""
    if not template.outputs:
        return None

    lines = []
    lines.append('"""Template outputs."""')
    lines.append("")
    lines.append("from . import *  # noqa: F403")
    lines.append("")
    lines.append("")

    ctx = pkg_ctx.codegen_ctx

    for output in template.outputs.values():
        class_def = generate_output_class(output, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.outputs_exports.add(f"{output.logical_id}Output")

    while lines and lines[-1] == "":
        lines.pop()

    return "\n".join(lines) + "\n"


# =============================================================================
# Resource Files Generation
# =============================================================================


def _generate_resource_files(
    pkg_ctx: PackageContext, template: IRTemplate
) -> dict[str, str]:
    """Generate resource files."""
    files = {}
    ctx = pkg_ctx.codegen_ctx

    sccs = find_strongly_connected_components(template)

    resource_to_scc: dict[str, int] = {}
    for scc_idx, scc in enumerate(sccs):
        for resource_id in scc:
            resource_to_scc[resource_id] = scc_idx

    scc_orderings: dict[int, list[str]] = {}
    for scc_idx, scc in enumerate(sccs):
        if len(scc) > 1:
            scc_orderings[scc_idx] = order_scc_resources(scc, template)

    sorted_resources = topological_sort(template)
    resource_classes: dict[str, str] = {}

    for resource_id in sorted_resources:
        resource = template.resources[resource_id]

        scc_idx = resource_to_scc[resource_id]
        if scc_idx in scc_orderings:
            ordered_scc = scc_orderings[scc_idx]
            resource_pos = ordered_scc.index(resource_id)
            ctx.forward_references = set(ordered_scc[resource_pos + 1 :])
        else:
            ctx.forward_references = set()

        resource_class = generate_resource_class(resource, ctx)
        resource_classes[resource_id] = resource_class
        pkg_ctx.resources_exports.add(resource_id)

    ctx.forward_references = set()

    # Group resources
    main_py_resources: list[str] = []
    separate_files: dict[str, list[str]] = {}
    generated_sccs: set[int] = set()

    for resource_id in sorted_resources:
        scc_idx = resource_to_scc[resource_id]
        if scc_idx in generated_sccs:
            continue
        generated_sccs.add(scc_idx)

        scc = sccs[scc_idx]

        if len(scc) > 1:
            main_py_resources.extend(scc_orderings[scc_idx])
        else:
            resource = template.resources[resource_id]
            category = get_resource_category(resource)
            if category == "main":
                main_py_resources.append(resource_id)
            else:
                if category not in separate_files:
                    separate_files[category] = []
                separate_files[category].append(resource_id)

    # Re-sort
    topo_order = {rid: idx for idx, rid in enumerate(sorted_resources)}
    main_py_resources.sort(key=lambda rid: topo_order[rid])
    for category in separate_files:
        separate_files[category].sort(key=lambda rid: topo_order[rid])

    # Generate main.py
    if main_py_resources:
        lines = []
        lines.append('"""Stack resources."""')
        lines.append("")
        lines.append("from . import *  # noqa: F403")
        lines.append("")
        lines.append("")

        for res_id in main_py_resources:
            resource_class = resource_classes[res_id]
            lines.append(resource_class)
            lines.append("")
            lines.append("")

        while lines and lines[-1] == "":
            lines.pop()

        files["main.py"] = "\n".join(lines) + "\n"

    # Generate category files
    for filename, resource_ids in separate_files.items():
        lines = []
        resource_names = ", ".join(resource_ids)
        lines.append(f'"""{filename.title()} resources: {resource_names}."""')
        lines.append("")
        lines.append("from . import *  # noqa: F403")
        lines.append("")
        lines.append("")

        for res_id in resource_ids:
            resource_class = resource_classes[res_id]
            lines.append(resource_class)
            lines.append("")
            lines.append("")

        while lines and lines[-1] == "":
            lines.pop()

        files[f"{filename}.py"] = "\n".join(lines) + "\n"

    return files
