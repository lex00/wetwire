package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

// GenerationStats tracks what was generated.
type GenerationStats struct {
	Services      int
	Resources     int
	PropertyTypes int
	FilesWritten  int
}

// generateCode generates Go files for all services.
func generateCode(services []*Service, outputDir string, dryRun bool) (*GenerationStats, error) {
	stats := &GenerationStats{
		Services: len(services),
	}

	for _, svc := range services {
		if err := generateService(svc, outputDir, dryRun, stats); err != nil {
			return stats, fmt.Errorf("generating %s: %w", svc.Name, err)
		}
	}

	return stats, nil
}

func generateService(svc *Service, outputDir string, dryRun bool, stats *GenerationStats) error {
	// Create service directory
	svcDir := filepath.Join(outputDir, svc.Name)
	if !dryRun {
		if err := os.MkdirAll(svcDir, 0755); err != nil {
			return err
		}
	}

	// Generate each resource as a separate file
	for _, res := range svc.Resources {
		code, err := generateResource(svc, res)
		if err != nil {
			return fmt.Errorf("generating %s: %w", res.Name, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(res.Name)+".go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
		stats.Resources++
	}

	// Generate doc.go for the package
	docCode := generateDoc(svc)
	docFile := filepath.Join(svcDir, "doc.go")
	if dryRun {
		fmt.Printf("Would write: %s\n", docFile)
	} else {
		if err := os.WriteFile(docFile, docCode, 0644); err != nil {
			return err
		}
		stats.FilesWritten++
	}

	return nil
}

var resourceTemplate = template.Must(template.New("resource").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}

import (
	wetwire "github.com/lex00/wetwire-aws"
)

{{ if .Documentation }}
// {{ .ResourceName }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}
// {{ .ResourceName }} represents {{ .CFType }}.
{{ end }}
type {{ .ResourceName }} struct {
	// Attributes for Fn::GetAtt
{{ range .Attributes }}	{{ .Name }} wetwire.AttrRef ` + "`json:\"-\"`" + `
{{ end }}
	// Properties
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}

// ResourceType returns the CloudFormation resource type.
func (r {{ .ResourceName }}) ResourceType() string {
	return "{{ .CFType }}"
}
`))

type resourceTemplateData struct {
	PackageName  string
	ResourceName string
	CFType       string
	Documentation string
	Timestamp    string
	Properties   []propertyData
	Attributes   []attributeData
}

type propertyData struct {
	Name          string
	GoType        string
	JSONName      string
	Documentation string
}

type attributeData struct {
	Name string
}

func generateResource(svc *Service, res ParsedResource) ([]byte, error) {
	// Prepare properties
	var props []propertyData
	propNames := make([]string, 0, len(res.Properties))
	for name := range res.Properties {
		propNames = append(propNames, name)
	}
	sort.Strings(propNames)

	for _, name := range propNames {
		prop := res.Properties[name]
		goType := prop.GoType

		// Handle pointers for optional fields
		if prop.IsPointer {
			goType = "*" + goType
		}

		// Clean up documentation
		doc := cleanDoc(prop.Documentation)

		props = append(props, propertyData{
			Name:          name,
			GoType:        goType,
			JSONName:      name,
			Documentation: doc,
		})
	}

	// Prepare attributes
	var attrs []attributeData
	attrNames := make([]string, 0, len(res.Attributes))
	for name := range res.Attributes {
		attrNames = append(attrNames, name)
	}
	sort.Strings(attrNames)

	for _, name := range attrNames {
		attrs = append(attrs, attributeData{
			Name: name,
		})
	}

	// Clean up documentation
	doc := cleanDoc(res.Documentation)

	data := resourceTemplateData{
		PackageName:   svc.Name,
		ResourceName:  res.Name,
		CFType:        res.CFType,
		Documentation: doc,
		Timestamp:     time.Now().Format(time.RFC3339),
		Properties:    props,
		Attributes:    attrs,
	}

	var buf bytes.Buffer
	if err := resourceTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.Bytes(), nil
	}

	return formatted, nil
}

func generateDoc(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("// Package %s provides CloudFormation resources for AWS %s.\n",
		svc.Name, strings.ToUpper(svc.Name)))
	buf.WriteString(fmt.Sprintf("package %s\n", svc.Name))
	return buf.Bytes()
}

// toSnakeCase converts PascalCase to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// cleanDoc cleans up CloudFormation documentation for Go comments.
func cleanDoc(doc string) string {
	if doc == "" {
		return ""
	}
	// Remove URLs and HTML
	doc = strings.ReplaceAll(doc, "\n", " ")
	if idx := strings.Index(doc, "http"); idx != -1 {
		doc = doc[:idx]
	}
	doc = strings.TrimSpace(doc)
	if len(doc) > 200 {
		doc = doc[:200] + "..."
	}
	return doc
}
