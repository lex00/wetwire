package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

// GenerationStats tracks what was generated.
type GenerationStats struct {
	Services      int
	Resources     int
	PropertyTypes int
	FilesWritten  int
}

// generateCode generates Go files for all services.
func generateCode(services []*Service, outputDir string, dryRun bool) (*GenerationStats, error) {
	stats := &GenerationStats{
		Services: len(services),
	}

	for _, svc := range services {
		if err := generateService(svc, outputDir, dryRun, stats); err != nil {
			return stats, fmt.Errorf("generating %s: %w", svc.Name, err)
		}
	}

	return stats, nil
}

func generateService(svc *Service, outputDir string, dryRun bool, stats *GenerationStats) error {
	// Create service directory
	svcDir := filepath.Join(outputDir, svc.Name)
	if !dryRun {
		if err := os.MkdirAll(svcDir, 0755); err != nil {
			return err
		}
	}

	// Generate each resource as a separate file
	for _, res := range svc.Resources {
		code, err := generateResource(svc, res)
		if err != nil {
			return fmt.Errorf("generating %s: %w", res.Name, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(res.Name)+".go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
		stats.Resources++
	}

	// Group property types by parent resource
	typesByResource := make(map[string][]string) // resourceName -> list of property type names
	for name, propType := range svc.PropertyTypes {
		parent := propType.ParentResource
		typesByResource[parent] = append(typesByResource[parent], name)
	}

	// Generate per-resource type files (e.g., security_group_types.go)
	for resourceName, typeNames := range typesByResource {
		sort.Strings(typeNames)

		code, err := generateResourcePropertyTypes(svc, resourceName, typeNames)
		if err != nil {
			return fmt.Errorf("generating property types for %s: %w", resourceName, err)
		}

		filename := filepath.Join(svcDir, toSnakeCase(resourceName)+"_types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", filename)
		} else {
			if err := os.WriteFile(filename, code, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}
	stats.PropertyTypes += len(svc.PropertyTypes)

	// Generate types.go for shared types (Tag only, unless service has Tag resource)
	_, hasTagResource := svc.Resources["Tag"]
	if !hasTagResource {
		typesCode := generateSharedTypes(svc)
		typesFile := filepath.Join(svcDir, "types.go")
		if dryRun {
			fmt.Printf("Would write: %s\n", typesFile)
		} else {
			if err := os.WriteFile(typesFile, typesCode, 0644); err != nil {
				return err
			}
			stats.FilesWritten++
		}
	}

	// Generate doc.go for the package
	docCode := generateDoc(svc)
	docFile := filepath.Join(svcDir, "doc.go")
	if dryRun {
		fmt.Printf("Would write: %s\n", docFile)
	} else {
		if err := os.WriteFile(docFile, docCode, 0644); err != nil {
			return err
		}
		stats.FilesWritten++
	}

	return nil
}

var resourceTemplate = template.Must(template.New("resource").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if .HasAttributes }}
import (
	wetwire "github.com/lex00/wetwire-aws"
)
{{ end }}
{{ if .Documentation }}
// {{ .ResourceName }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}
// {{ .ResourceName }} represents {{ .CFType }}.
{{ end }}
type {{ .ResourceName }} struct {
{{ if .HasAttributes }}	// Attributes for Fn::GetAtt
{{ range .Attributes }}	{{ .GoName }} wetwire.AttrRef ` + "`json:\"-\"`" + `
{{ end }}{{ end }}
	// Properties
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}

// ResourceType returns the CloudFormation resource type.
func (r {{ .ResourceName }}) ResourceType() string {
	return "{{ .CFType }}"
}
`))

type resourceTemplateData struct {
	PackageName   string
	ResourceName  string
	CFType        string
	Documentation string
	Timestamp     string
	Properties    []propertyData
	Attributes    []attributeData
	HasAttributes bool // true if there are any attributes (for conditional import)
}

type propertyData struct {
	Name          string
	GoType        string
	JSONName      string
	Documentation string
}

type attributeData struct {
	Name    string
	GoName  string // Sanitized Go identifier
	CFName  string // Original CloudFormation attribute name
}

func generateResource(svc *Service, res ParsedResource) ([]byte, error) {
	// Build map of property type names to qualified names for this service
	// Property types are named as ParentResource_PropertyType
	// When multiple property types share the same simple name, prefer the one
	// from the same parent resource as the current resource.
	propTypeNames := make(map[string]string)
	for ptName, pt := range svc.PropertyTypes {
		qualifiedName := pt.ParentResource + "_" + ptName
		// Prefer property types from the same parent resource
		if pt.ParentResource == res.Name {
			propTypeNames[ptName] = qualifiedName
		} else if _, exists := propTypeNames[ptName]; !exists {
			propTypeNames[ptName] = qualifiedName
		}
	}

	// Prepare properties
	var props []propertyData
	propNames := make([]string, 0, len(res.Properties))
	for name := range res.Properties {
		propNames = append(propNames, name)
	}
	sort.Strings(propNames)

	for _, name := range propNames {
		prop := res.Properties[name]
		goType := resolveTypeReferences(prop.GoType, propTypeNames, prop.IsPointer)

		// Convert property type fields to any to allow both typed structs and map literals
		// This enables the importer to generate flexible code without knowing exact type names
		goType = flexiblePropertyType(goType, propTypeNames)

		// Clean up documentation
		doc := cleanDoc(prop.Documentation)

		// Rename properties that conflict with struct methods
		goName := name
		if name == "ResourceType" {
			goName = "ResourceTypeProp"
		}

		props = append(props, propertyData{
			Name:          goName,
			GoType:        goType,
			JSONName:      name,
			Documentation: doc,
		})
	}

	// Build set of property names to avoid attribute conflicts
	propNameSet := make(map[string]bool)
	for _, p := range props {
		propNameSet[p.Name] = true
	}

	// Prepare attributes (sanitized and non-conflicting)
	var attrs []attributeData
	attrNames := make([]string, 0, len(res.Attributes))
	for name := range res.Attributes {
		attrNames = append(attrNames, name)
	}
	sort.Strings(attrNames)

	for _, name := range attrNames {
		// Sanitize: replace dots with underscores for valid Go identifiers
		goName := strings.ReplaceAll(name, ".", "_")
		// Skip attributes that conflict with property names
		if propNameSet[goName] {
			continue
		}
		// Rename attributes that conflict with struct methods
		if goName == "ResourceType" {
			goName = "ResourceTypeAttr"
		}
		attrs = append(attrs, attributeData{
			Name:   goName,
			GoName: goName,
			CFName: name,
		})
	}

	// Clean up documentation
	doc := cleanDoc(res.Documentation)

	data := resourceTemplateData{
		PackageName:   svc.Name,
		ResourceName:  res.Name,
		CFType:        res.CFType,
		Documentation: doc,
		Timestamp:     time.Now().Format(time.RFC3339),
		Properties:    props,
		Attributes:    attrs,
		HasAttributes: len(attrs) > 0,
	}

	var buf bytes.Buffer
	if err := resourceTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.Bytes(), nil
	}

	return formatted, nil
}

func generateDoc(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("// Package %s provides CloudFormation resources for AWS %s.\n",
		svc.Name, strings.ToUpper(svc.Name)))
	buf.WriteString(fmt.Sprintf("package %s\n", svc.Name))
	return buf.Bytes()
}

// isGoKeyword checks if a name is a Go keyword.
func isGoKeyword(s string) bool {
	keywords := map[string]bool{
		"break": true, "case": true, "chan": true, "const": true, "continue": true,
		"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
		"func": true, "go": true, "goto": true, "if": true, "import": true,
		"interface": true, "map": true, "package": true, "range": true, "return": true,
		"select": true, "struct": true, "switch": true, "type": true, "var": true,
	}
	return keywords[strings.ToLower(s)]
}

// toSnakeCase converts PascalCase to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// resolveTypeReferences resolves property type names to their qualified names.
// Handles simple types, slices, maps, and pointers.
func resolveTypeReferences(goType string, qualifiedNames map[string]string, isPointer bool) string {
	// Handle slice types like []SomeType
	if strings.HasPrefix(goType, "[]") {
		baseType := strings.TrimPrefix(goType, "[]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "[]" + qn
		}
		return goType
	}

	// Handle map types like map[string]SomeType
	if strings.HasPrefix(goType, "map[string]") {
		baseType := strings.TrimPrefix(goType, "map[string]")
		if qn, ok := qualifiedNames[baseType]; ok {
			return "map[string]" + qn
		}
		return goType
	}

	// Handle simple types
	if qn, ok := qualifiedNames[goType]; ok {
		goType = qn
	}

	// Handle pointers for optional fields (after type resolution)
	if isPointer {
		goType = "*" + goType
	}

	return goType
}

// flexiblePropertyType converts property type fields to any to allow both typed structs
// and inline map literals. This enables the importer to generate flexible code.
func flexiblePropertyType(goType string, propTypeNames map[string]string) string {
	// If already any or primitive-like, leave it
	if goType == "any" || goType == "[]any" || goType == "map[string]any" {
		return goType
	}

	// Tags field uses []any to allow intrinsics.Tag from dot import
	if goType == "[]Tag" {
		return "[]any"
	}

	// Check if this is a property type reference (contains underscore pattern like "Resource_Type")
	isPropertyType := func(t string) bool {
		// Strip slice/pointer prefix
		base := strings.TrimPrefix(strings.TrimPrefix(t, "*"), "[]")
		// Check if it's a qualified name (contains underscore) from property types
		for _, qn := range propTypeNames {
			if base == qn {
				return true
			}
		}
		// Also check for underscore pattern indicating a property type
		return strings.Contains(base, "_")
	}

	// Handle slice types like []SomeResource_Type -> []any
	if strings.HasPrefix(goType, "[]") && isPropertyType(goType) {
		return "[]any"
	}

	// Handle pointer types like *SomeResource_Type -> any
	if strings.HasPrefix(goType, "*") && isPropertyType(goType) {
		return "any"
	}

	// Handle non-pointer property types -> any
	if isPropertyType(goType) {
		return "any"
	}

	return goType
}

// cleanDoc cleans up CloudFormation documentation for Go comments.
func cleanDoc(doc string) string {
	if doc == "" {
		return ""
	}
	// Remove URLs and HTML
	doc = strings.ReplaceAll(doc, "\n", " ")
	if idx := strings.Index(doc, "http"); idx != -1 {
		doc = doc[:idx]
	}
	doc = strings.TrimSpace(doc)
	if len(doc) > 200 {
		doc = doc[:200] + "..."
	}
	return doc
}

var propertyTypesTemplate = template.Must(template.New("types").Parse(`// Code generated by wetwire-aws codegen. DO NOT EDIT.
// Source: CloudFormation Resource Specification
// Generated: {{ .Timestamp }}

package {{ .PackageName }}
{{ if not .SkipTag }}
// Tag represents a CloudFormation tag.
// This is a shared type used across all services.
type Tag struct {
	Key   string ` + "`json:\"Key\"`" + `
	Value any    ` + "`json:\"Value\"`" + `
}
{{ end }}

{{ range .Types }}
{{ if .Documentation }}// {{ .Name }} represents {{ .CFType }}.
// {{ .Documentation }}
{{ else }}// {{ .Name }} represents {{ .CFType }}.
{{ end }}type {{ .Name }} struct {
{{ range .Properties }}{{ if .Documentation }}	// {{ .Documentation }}
{{ end }}	{{ .Name }} {{ .GoType }} ` + "`json:\"{{ .JSONName }},omitempty\"`" + `
{{ end }}}
{{ end }}
`))

type typesTemplateData struct {
	PackageName string
	Timestamp   string
	Types       []typeData
	SkipTag     bool // True if the service has a Tag resource (to avoid conflict)
}

type typeData struct {
	Name          string
	CFType        string
	Documentation string
	Properties    []propertyData
}

// generateSharedTypes generates types.go with only shared types (Tag).
func generateSharedTypes(svc *Service) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by wetwire-aws codegen. DO NOT EDIT.\n")
	buf.WriteString("// Source: CloudFormation Resource Specification\n")
	buf.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().Format(time.RFC3339)))
	buf.WriteString(fmt.Sprintf("package %s\n\n", svc.Name))
	buf.WriteString("// Tag represents a CloudFormation tag.\n")
	buf.WriteString("// This is a shared type used across all services.\n")
	buf.WriteString("type Tag struct {\n")
	buf.WriteString("\tKey   string `json:\"Key\"`\n")
	buf.WriteString("\tValue any    `json:\"Value\"`\n")
	buf.WriteString("}\n")
	return buf.Bytes()
}

// generateResourcePropertyTypes generates a {resource}_types.go file for property types of a single resource.
func generateResourcePropertyTypes(svc *Service, resourceName string, typeNames []string) ([]byte, error) {
	// Build qualified names map for type reference resolution
	qualifiedNames := make(map[string]string)
	for name, propType := range svc.PropertyTypes {
		qualifiedName := propType.ParentResource + "_" + name
		if _, exists := qualifiedNames[name]; !exists {
			qualifiedNames[name] = qualifiedName
		}
		qualifiedNames[qualifiedName] = qualifiedName
	}

	var types []typeData
	for _, name := range typeNames {
		propType := svc.PropertyTypes[name]
		qualifiedName := resourceName + "_" + name

		// Sort properties
		propNames := make([]string, 0, len(propType.Properties))
		for pn := range propType.Properties {
			propNames = append(propNames, pn)
		}
		sort.Strings(propNames)

		var props []propertyData
		for _, pn := range propNames {
			prop := propType.Properties[pn]
			goType := resolveTypeReferences(prop.GoType, qualifiedNames, prop.IsPointer)

			goName := pn
			if isGoKeyword(pn) {
				goName = pn + "_"
			}

			props = append(props, propertyData{
				Name:          goName,
				GoType:        goType,
				JSONName:      pn,
				Documentation: cleanDoc(prop.Documentation),
			})
		}

		types = append(types, typeData{
			Name:          qualifiedName,
			CFType:        propType.CFType,
			Documentation: cleanDoc(propType.Documentation),
			Properties:    props,
		})
	}

	data := typesTemplateData{
		PackageName: svc.Name,
		Timestamp:   time.Now().Format(time.RFC3339),
		Types:       types,
		SkipTag:     true, // Always skip Tag in per-resource files (it's in types.go)
	}

	var buf bytes.Buffer
	if err := propertyTypesTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), nil
	}

	return formatted, nil
}

// generatePropertyTypes generates the types.go file with all property types.
// NOTE: This function is kept for reference but is no longer used.
// Property types are now split into per-resource files.
func generatePropertyTypes(svc *Service) ([]byte, error) {
	// Build set of resource names to detect collisions
	resourceNames := make(map[string]bool)
	for name := range svc.Resources {
		resourceNames[name] = true
	}

	// Sort property type names for deterministic output
	typeNames := make([]string, 0, len(svc.PropertyTypes))
	for name := range svc.PropertyTypes {
		typeNames = append(typeNames, name)
	}
	sort.Strings(typeNames)

	// Build map of property type names to their qualified names
	// (parent resource + property type name, e.g., "Instance_BlockDeviceMapping")
	// Note: Some property types may have the same simple name from different resources.
	// We use the first occurrence for the simple name lookup.
	qualifiedNames := make(map[string]string)
	for _, name := range typeNames {
		propType := svc.PropertyTypes[name]
		// Use parent resource prefix to avoid collisions
		qualifiedName := propType.ParentResource + "_" + name
		// Only map simple name if not already mapped (avoid overwriting)
		if _, exists := qualifiedNames[name]; !exists {
			qualifiedNames[name] = qualifiedName
		}
		// Always map the full qualified name to itself for explicit lookups
		qualifiedNames[qualifiedName] = qualifiedName
	}

	var types []typeData
	for _, name := range typeNames {
		propType := svc.PropertyTypes[name]
		qualifiedName := qualifiedNames[name]

		// Sort properties
		propNames := make([]string, 0, len(propType.Properties))
		for pn := range propType.Properties {
			propNames = append(propNames, pn)
		}
		sort.Strings(propNames)

		var props []propertyData
		for _, pn := range propNames {
			prop := propType.Properties[pn]
			goType := resolveTypeReferences(prop.GoType, qualifiedNames, prop.IsPointer)

			// Sanitize property name if it's a Go keyword
			goName := pn
			if isGoKeyword(pn) {
				goName = pn + "_"
			}

			props = append(props, propertyData{
				Name:          goName,
				GoType:        goType,
				JSONName:      pn,
				Documentation: cleanDoc(prop.Documentation),
			})
		}

		types = append(types, typeData{
			Name:          qualifiedName,
			CFType:        propType.CFType,
			Documentation: cleanDoc(propType.Documentation),
			Properties:    props,
		})
	}

	// Check if service has a Tag resource (to skip generating common Tag type)
	_, hasTagResource := svc.Resources["Tag"]

	data := typesTemplateData{
		PackageName: svc.Name,
		Timestamp:   time.Now().Format(time.RFC3339),
		Types:       types,
		SkipTag:     hasTagResource,
	}

	var buf bytes.Buffer
	if err := propertyTypesTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.Bytes(), nil
	}

	return formatted, nil
}
